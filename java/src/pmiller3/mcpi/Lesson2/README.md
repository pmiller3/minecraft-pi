# Lesson 2 - Jump!
This lesson will build on the last.  We know we can talk and connect to Minecraft pi - now let's do something in the game world.  Luckily, there's some [documentation](https://pimylifeup.com/minecraft-pi-edition-api-reference/) out there that let's us know what we can do with our library once connected.  Unfortunately, that's the Python API, and the Java API uses slightly different names and syntax, so you might have to use Intellisense to figure out exactly what you want, but they should all be available in some form or fashion.

You should be able to open `Jump.java` in VSCode or any other properly configured Java IDE of your choice and just run it once you have also opened Minecraft pi edition (this may or may not be installed by default).

Also, we're going to cover two other things: first, the programming concept of variables, and second, .gitignore which is a tool for handling what files are ignored by git (useful for, say, hiding files generated by the system or custom configurations that don't apply elsewhere, like the IP address of your pi).

## Goals
- Storing information in a variable, and Vectors
- API calls to gather info about the world (in this case, the player position)
- API calls to set something in the world (in this case, translate the player position)
- Reading from a file (not Minecraft, just coding!)
- Introduction to .gitignore

## Breakdown
The `Jump.java` is only a few more lines of code added to our `HelloMinecraft.java`.  For purposes of this lesson, we'll break down only the new bits.

We can't actually tell the player to 'jump' through the API, and they can already do that on the keyboard (ok, so they can fly too, but... nevermind that).  But what we can do is figure out where they are, and move them up, so let's do that.

```
        // Ask the Minecraft game where the player is and store it
        Vec playerPosition = minecraft.player.getPosition();
```

This line reaches out to the game, and says, whereever the player is, give me that information, and store it in a variable called `playerPosition`.  Now, this is interesting, because the player position is actually a Vector, so it contains 3 numbers, referred to as `x`, `y`, and `z`.  We'll see uses of syntax to get these bits ouf of it in a second, but just know that we've got the coordinates of the player in the XYZ-coordinate 3d space that is the game.  This is actually our second example of variable storage... `minecraft` from the line `minecraft = Minecraft.create()` was really the first!

```
        // We can see in the output, the player position is represented
        // as a vector with 3 numbers in it - these are the X, Y and Z
        // coordinates in 3d space
        System.out.println(playerPosition);
```

This line is just so you can see what's stored, you'll get some output like `Vec3(18.4532,16.0,1.49925)` - that is the position of the player.  Of course your numbers will differ from mine, almost certainly, and they'll differ as the player moves.

```
        // A more convenient syntax we can use to get just the 3 integers
        int x = playerPosition.x, y = playerPosition.y, z = playerPosition.z;
```

Here's a convenience to get the three numbers on your own... you don't need to do this, but below I'll show you how it's cleaner in some cases.  It's also 3 more variable assignments!  Variables are just things to hold data that can or does change during execution of your program, and now we've got several of them (indeed, we don't know what the player's position is when we run the script).

```
        // So, to jump, we just have to move the player "up"!
        // This is done by increasing the y coordinate of the position
        // Lots of alternate ways to express this, creating a new object or using
        // built in vector math on the existing playerPosition
        // minecraft.player.setPosition(Vec.xyz(playerPosition.x, playerPosition.y + 10, playerPosition.z));
        // minecraft.player.setPosition(Vec.xyz(x, y + 10, z));
        minecraft.player.setPosition(playerPosition.add(0, 10, 0));
```

Here, we're doing the actual work fo moving up, and I've left in a line where you didn't actually break out the x, y, and z, and you can see how much cleaner it is on the alternative and the line left in.  But that's it!  We tell the game to set the player's position to the same x coordinate, 10 more than the y coordinate (up), and the same z coordinate.  So it's like they jumped, much higher than normal.

## Reading config from a file
To make this a little easier to use, and to allow someone to run the code on one machine (doesn't even have to be a Pi), while seeing the results on another Pi, I've added a convenient top-level file called `.config` that is in JSON format.  It's a pretty simple little file, that will just house where our code should try to connect to.  This is built-in Python behavior, and reading files, storing their contents in variables, has nothing to do with Minecraft - so this is a useful tool in all your projects.  First, the JSON file itself, `.config`:

```
host=localhost
```
I've left this example pointing to `localhost` but normally you'd want to point to some IP address, probably a local one on your network that will look like `192.168.123.123`.  If you're on your pi, you can open a terminal and use the `ifconfig` command to find it (and it will spit out several, including your internet facing IP address).  It's somewhat sensitive, and not worth storing in a shared repo, but the next bit will cover that.

```
// imports for reading config file
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;
...
public class Jump {
    // Let's have a place to keep our host
    private static String host = "localhost";
...
    // Read the configuration file and populate host
    public static void readConfig() {
        Properties properties = new Properties();
        InputStream filestream = null;
        try {
            filestream = new FileInputStream(".config");
            properties.load(filestream);
            host = properties.getProperty("host");
        } catch (FileNotFoundException ex) {
            System.err.println("No .config file found; using defaults.");
        } catch (IOException ex) {
            System.err.println("Input/Output exception when streaming .config file; using defaults.");
        }
    }
```

And that's the code itself.  It has a `try` statement which is beyond the scope of this lesson, but no need to worry - it sets a default host option of localhost, and if it can open the file, and read a value for `host` then it will put that value there.  It'll print that value to the console so you can see what's actually read in, and later on, it uses that value to connect to Minecraft.  Now we're able to dynamically connect, and can code the next project on a different machine, or not.

## Using .gitignore to keep files out of source control

So now that we have our config, we probably want to keep something like the IP address safe, or at least not shared because my IP address is not yours, and it won't work for you.  So simply, git allows for a file already part of this repo, `.gitignore` that defines what files should not be part of what gets passed around.  Besides secure files, we don't want to put up anything generated (there are of course exceptions to every rule) and the one I had was pre-configured for Python.  All I've done is add one little section (this is in a new top-level config file, so it's shared with all my sub-projects in this whole repo), ignoring the aforementioned config file, and we can use the `#` character to comment as well, so that anyone else (including our future self) can understand the intent there:

```
# Ignore config file, it contains an IP address
.config
```