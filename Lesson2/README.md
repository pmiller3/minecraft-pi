# Lesson 2 - Jump!
This lesson will build on the last.  We know we can talk and connect to Minecraft pi - now let's do something in the game world.  Luckily, there's some [documentation](https://pimylifeup.com/minecraft-pi-edition-api-reference/) out there that let's us know what we can do with our library once connected.

You should be able to open `Jump.py` in Thonny or any other properly configured Python IDE of your choice (for the pi itself with the recommended OS, Thonny is configured out of the box), and just run it once you have also opened Minecraft pi edition (this may or may not be installed by default).

Also, we're going to cover two other things: first, the programming concept of variables, and second, .gitignore which is a tool for handling what files are ignored by git (useful for, say, hiding files generated by the system or custom configurations that don't apply elsewhere, like the IP address of your pi).

## Goals
- Storing information in a variable, and Vectors
- API calls to gather info about the world (in this case, the player position)
- API calls to set something in the world (in this case, translate the player position)
- Reading from a file (not Minecraft, just coding!)
- Introduction to .gitignore

## Breakdown
The `Jump.py` is only a few more lines of code added to our `HelloMinecraft.py`.  For purposes of this lesson, we'll break down only the new bits.

We can't actually tell the player to 'jump' through the API, and they can already do that on the keyboard (ok, so they can fly too, but... nevermind that).  But what we can do is figure out where they are, and move them up, so let's do that.

```
# Ask the Minecraft game where the player is
playerPosition = minecraft.player.getPos()
```

This line reaches out to the game, and says, whereever the player is, give me that information, and store it in a variable called `playerPosition`.  Now, this is interesting, because the player position is actually a Vector, so it contains 3 numbers, referred to as `x`, `y`, and `z`.  We'll see uses of syntax to get these bits ouf of it in a second, but just know that we've got the coordinates of the player in the XYZ-coordinate 3d space that is the game.  This is actually our second example of variable storage... `minecraft` from the line `minecraft = Minecraft.create()` was really the first!

```
# We can see in the output, the player position is represented
# as a vector with 3 numbers in it - these are the X, Y and Z
# coordinates in 3d space
print(playerPosition)
```

This line is just so you can see what's stored, you'll get some output like `Vec3(18.4532,16.0,1.49925)` - that is the position of the player.  Of course your numbers will differ from mine, almost certainly, and they'll differ as the player moves.

```
# A more convenient syntax we can use
x, y, z = playerPosition
```

Here's a convenience to get the three numbers on your own... you don't need to do this, but below I'll show you how it's cleaner (and you can actually do this directly as `x, y, z = minecraft.player.getPos()`).  It's also 3 more variable assignments!  Variables are just things to hold data that can or does change during execution of your program, and now we've got several of them (indeed, we don't know what the player's position is when we run the script).

```
# So, to jump, we just have to move the player "up"!
# This is done by increasing the y coordinate of the position
#minecraft.player.setPos(playerPosition.x, playerPosition.y + 10, playerPosition.z)
minecraft.player.setPos(x, y + 10, z)
```

Here, we're doing the actual work fo moving up, and I've left in a line where you didn't actually break out the x, y, and z, and you can see how much cleaner it is on the line left in.  But that's it!  We tell the game to set the player's position to the same x coordinate, 10 more than the y coordinate (up), and the same z coordinate.  So it's like they jumped, much higher than normal.

## Reading config from a file
To make this a little easier to use, and to allow someone to run the code on one machine (doesn't even have to be a Pi), while seeing the results on another Pi, I've added a convenient top-level file called `.config` that is in JSON format.  It's a pretty simple little file, that will just house where our code should try to connect to.  This is built-in Python behavior, and reading files, storing their contents in variables, has nothing to do with Minecraft - so this is a useful tool in all your projects.  First, the JSON file itself, `.config`:

```
{
    "minecraft":{
        "host":"localhost"
    }
}
```
I've left this example pointing to `localhost` but normally you'd want to point to some IP address, probably a local one on your network that will look like `192.168.123.123`.  If you're on your pi, you can open a terminal and use the `ifconfig` command to find it (and it will spit out several, including your internet facing IP address).  It's somewhat sensitive, and not worth storing in a shared repo, but the next bit will cover that.

```
# Import the JSON library so we can parse our JSON config
import json

# Open the config
host = 'localhost'    
try:
    with open('.config') as json_config:
        config = json.load(json_config)
        host = config['minecraft']['host']
except IOError:
    print("No config file loaded")
print("Connecting to: " + host)

# Create and store a connection to our game in a variable
minecraft = Minecraft.create(host)
```

And that's the code itself.  It has a `try` statement which is beyond the scope of this lesson, but no need to worry - it sets a default host option of localhost, and if it can open the file, and read a value for `minecraft.host` then it will put that value there.  It'll print that value to the console so you can see what's actually read in, and later on, it uses that value to connect to Minecraft.  Now we're able to dynamically connect, and can code the next project on a different machine, or not.

## Using .gitignore to keep files out of source control

So now that we have our config, we probably want to keep something like the IP address safe, or at least not shared because my IP address is not yours, and it won't work for you.  So simply, git allows for a file already part of this repo, `.gitignore` that defines what files should not be part of what gets passed around.  Besides secure files, we don't want to put up anything generated (there are of course exceptions to every rule) and the one I had was pre-configured for Python.  All I've done is add one little section (this is in a new top-level config file, so it's shared with all my sub-projects in this whole repo), ignoring the aforementioned config file, and we can use the `#` character to comment as well, so that anyone else (including our future self) can understand the intent there:

```
# Ignore config file, it contains an IP address
.config
```